#! /usr/bin/env perl
#
# Andrew Janke - a.janke@gmail.com
#
#
# A simple interface to SGE + PBS qsub interface for the unwashed

use strict;
use warnings "all";
use Getopt::Long;
use Pod::Usage;
use File::Basename;
use IPC::Open2;
use Cwd;

# until I get organised and do this properly
my $PACKAGE = &basename($0);
my $VERSION = '1.4.0';
my $PACKAGE_BUGREPORT = '"Andrew Janke" <a.janke@gmail.com>';
 
my($me, %opt, @command, $script);

$me = &basename($0);
%opt = ('verbose' => 0,
        'type' => 'gridengine',
        'fake' => 0,
        'script' => undef,
        'queue' => undef,
        'jname' => 'STDIN',
        'depends' => undef,
        'log' => undef,
        'man' => 0,
        'help' => 0,
        'return_jid' => 0,
        );

# Check arguments
&GetOptions(
   'help|?' => \$opt{'help'},
   'man' => \$opt{'man'},
   'v|verbose' => \$opt{'verbose'},
   't|type=s' => \$opt{'type'},
   'version' => sub { &print_version_info },
   'f|fake' => \$opt{'fake'},
   's|script=s' => \$opt{'script'},
   'q|queue=s' => \$opt{'queue'},
   'N|name=s' => \$opt{'jname'},
   'd|depends=s' => \$opt{'depends'},
   'l|logfile=s' => \$opt{'logfile'},
   'j|jid' => \$opt{'return_jid'},
   ) or pod2usage('-verbose' => 1) && exit;
   
# handle -man, -help or missing args
pod2usage('-verbose' => 1) if $opt{'help'};
pod2usage('-exitstatus' => 0, -verbose => 2) if $opt{'man'};
pod2usage('-verbose' => 0) && exit if ($#ARGV < 0);

# the remainder now has to be the command (we hope!)
@command = @ARGV;

# attempt to fortify quoting in the command
foreach (@command){
   # add quotes to arguments with spaces
   if(m/\ /){
      $_ = "\'$_\'";
      }
   }

my($pwd, @pwvalues, $shell, @deps, $stdout, $stderr);

# Get current directory and user shell
$pwd = &cwd;
@pwvalues = getpwuid($<);
$shell = $pwvalues[8];

# clean up job name
$opt{'jname'} =~ s/(;|,|\s)/_/g;

# logfile
if(!defined($opt{'logfile'})){
   $opt{'logfile'} = "$pwd/$me-$$.log";
   }

# dependencies
@deps = (defined($opt{'depends'})) ? split(/\,/, $opt{'depends'}) : ();

chomp(my($submitted) = `date`);

# set up the script
$script = 
   "#! /bin/sh\n" .
   "#\n" .
   "# " . $ENV{'USER'} . " - " . `date` .
   "# This script was generated by $me\n" .
   "#\n" .

   # SGE syntax
   "# gridengine directives\n" .
   "#\$ -N $opt{'jname'}\n" .           # job name
   "#\$ -r y\n" .                       # rerun the job on fail
   "#\$ -S $shell\n" .                  # specify the shell

   "#\$ -j yes\n" .                     # join STDOUT and STDERR
   "#\$ -o $opt{'logfile'}\n" .         # logfile
   "#\$ -cwd\n" .                       # job is in the current directory
   "#\$ -V\n" .                         # export the current environment
   
   # queue
   ((defined($opt{'queue'})) ?
      "#\$ -q $opt{'queue'}\n" : "") .

   # dependencies
   (($#deps > -1) ?
      "#\$ -hold_jid " . join(',', @deps) . "\n" : "\n") .
   
   "\n" .

   # PBS syntax
   "# PBS directives\n" .
   "#PBS -r y\n" .                      # rerun the job on fail
   "#PBS -S $shell\n" .                 # specify the shell
   
   "#PBS -j oe\n" .                     # merge STDERR into STDOUT
   "#PBS -o $opt{'logfile'}\n" .        # logfile
   "#  PBS -V\n" .                        # export the current environment
   
   # job name (only 15 characters == fail)
   "#PBS -N " . substr($opt{'jname'}, 0, 15) . "\n" .
   
   # queue
   ((defined($opt{'queue'})) ?
      "#PBS -q $opt{'queue'}\n" : "") .
   
   # dependencies
   (($#deps > -1) ?
      "#PBS -W depend=afterany:" . join(':', @deps) . "\n" : "\n") .

   "\n" .

   "# Set the path as per the current user\n" .
   "export PATH=$ENV{'PATH'}\n" .
   "\n" .

   "# start logging\n" .
   "{\n" .
   
   # some logging output
   "echo \"## log from $me for $ENV{'USER'}\"\n" .
   "echo \"## \"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo \"## submitted:   $submitted\"\n" .
   "echo \"## started:     `date`\"\n" .
   "echo \"## host:        `uname -a`\"\n" .
   "echo \"## cwd:         $pwd\"\n" .
   "echo \"## command:     " . join(' ', @command) . "\"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo\n" .
   
   # finally the command itself
   "\n" .
   "# The command itself\n" .
   join(" ", @command) . "\n" .
   
   # record exit status
   "status=\$?\n\n" .
   
   # exit logging
   "echo\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo \"## finished:     `date`\"\n" .
   "echo \"## exit status:  \$status\"\n" .
   "echo \"## ----------------------------------------------\"\n" .
   "echo\n" .
   "echo\n" .
   "\n" .

   # send to logfile
   "} > $opt{'logfile'} 2>&1\n";

print STDOUT "-----SCRIPT-----\n" . 
             $script .
             "----------------\n" if $opt{'verbose'};

# dump script
if(defined($opt{'script'})){
   open(FH, ">$opt{'script'}");
   print FH $script;
   close(FH);
   
   chmod(0700, $opt{'script'});
   }

# open a pipe to qsub and collect job id
if(!$opt{'fake'}){
   my($pid, $jid);
   
   $pid = open2(\*QSUB_OUT, \*QSUB_IN, 'qsub');
   print QSUB_IN $script;
   close(QSUB_IN);
   waitpid($pid, 0);

   my $buf = "";
   while (<QSUB_OUT>){
      $buf .= $_;
      ($jid) = $_ =~ m/(\d+)/;
      }
   
   if($opt{'return_jid'}){
      print STDOUT "$jid\n";
      }
   else{
      print STDOUT $buf;
      }
   }

sub print_version_info {
   print STDOUT "\n$PACKAGE version $VERSION\n".
                "Comments to $PACKAGE_BUGREPORT\n\n";
   exit;
   }


__END__

=head1 NAME

B<qbatch> - submits a command line to Grid Engine or PBS via qsub

=head1 SYNOPSIS

B<qbatch> [options] [B<-q> queue] -- command

qbatch is designed to be inserted before any command that you would
usually run from the command line. In case of argument collision
where both your command and qbatch share an option such as --verbose
be sure to use the '--' syntax to split qbatch options from the 
commands options

   $ qbatch --verbose -- mincmath --verbose ...

=head1 DESCRIPTION

B<qbatch> is a quick hack if you don't want to write a B<qsub> script

The idea is to just bung B<qbatch> in front of any command you would 
normally enter on the command line. (as per 'nice')

 eg:
    $ qbatch ls -F
    $ qbatch -q wb325.q@taylor -N job23 -- mincmath fred.mnc ..

Problems or comments should be sent to: a.janke@gmail.com

=head1 OPTIONS

=over 4

=item B<-v>, B<--verbose>

Be noisy when doing things (most importantly this will echo the resulting script to the terminal)

=item B<--version>

Print version number and exit

=item B<-h>, B<--help>

Dump some quick help output

=item B<--man>

Dump a man page

=item B<-f>, B<--fake>

Don't run anything, This is useful when combined with --verbose or --script

=item B<-s>, B<--script>

Dont run anything, just output the batch script to the specified filename

=item B<--type>

Type of queing system, currently only pbs and gridengine are supported

=item B<-q>, B<--queue>

Specify a queue to run a job in. Use something like all.q@hostname to specify a particular host. 
Defaults to all.q, the default SGE queue

=item B<-N>, B<--name>

Specify a job name to run the job as. By default this will be "STDIN"

=item B<-d>, B<--depends>

Specify a list of job dependencies by job name or number which have to run before this job will

=item B<-l>, B<--logfile>

Logfile for output of the command. By Default this will make a file in the current directory called 
qbatch-<PID>.log where PID is the Process ID of the instance of qbatch

=item B<-j>, B<--jid>

return only the job id of the submitted job on STDOUT

=back

=head1 SEE ALSO

qsub(1) qdel(1)

=head1 AUTHOR

Andrew Janke - a.janke@gmail.com

=cut
